{"typeList":{"names":["*"]},"children":[{"name":"approximation","fullname":"plotOptions.networkgraph.layoutAlgorithm.approximation","isLeaf":true,"default":"none","typeMap":{"string":1},"typeList":{"names":["string"]},"description":"<p>Approximation used to calculate repulsive forces affecting nodes.\nBy default, when calculateing net force, nodes are compared\nagainst each other, which gives O(N^2) complexity. Using\nBarnes-Hut approximation, we decrease this to O(N log N), but the\nresulting graph will have different layout. Barnes-Hut\napproximation divides space into rectangles via quad tree, where\nforces exerted on nodes are calculated directly for nearby cells,\nand for all others, cells are treated as a separate node with\ncenter of mass.</p>\n","since":"7.1.0","samples":[{"name":"A graph with Barnes-Hut approximation","value":"highcharts/series-networkgraph/barnes-hut-approximation/"}],"see":["<p><a href=\"#series.networkgraph.layoutAlgorithm.theta\">layoutAlgorithm.theta</a></p>\n"],"filename":"js/Series/Networkgraph/Networkgraph.js","line":401,"lineEnd":420,"version":"fa929aa027"},{"name":"attractiveForce","fullname":"plotOptions.networkgraph.layoutAlgorithm.attractiveForce","isLeaf":true,"default":"function (d, k) { return k * k / d; }","typeMap":{"function":1},"typeList":{"names":["function"]},"description":"<p>Attraction force applied on a node which is conected to another\nnode by a link. Passed are two arguments:</p>\n<ul>\n<li><code>d</code> - which is current distance between two nodes</li>\n<li><code>k</code> - which is desired distance between two nodes</li>\n</ul>\n<p>In <code>verlet</code> integration, defaults to:\n<code>function (d, k) { return (k - d) / d; }</code></p>\n","since":"7.0.0","samples":[{"name":"Custom forces with Euler integration","value":"highcharts/series-networkgraph/forces/"},{"name":"Custom forces with Verlet integration","value":"highcharts/series-networkgraph/cuboids/"}],"see":["<p><a href=\"#series.networkgraph.layoutAlgorithm.integration\">layoutAlgorithm.integration</a></p>\n"],"filename":"js/Series/Networkgraph/Networkgraph.js","line":309,"lineEnd":328,"version":"fa929aa027"},{"name":"enableSimulation","fullname":"plotOptions.networkgraph.layoutAlgorithm.enableSimulation","isLeaf":true,"default":false,"typeMap":{"boolean":1},"typeList":{"names":["boolean"]},"description":"<p>Experimental. Enables live simulation of the algorithm\nimplementation. All nodes are animated as the forces applies on\nthem.</p>\n","since":"7.0.0","samples":[{"name":"Live simulation enabled","value":"highcharts/demo/network-graph/"}],"filename":"js/Series/Networkgraph/Networkgraph.js","line":365,"lineEnd":372,"version":"fa929aa027"},{"name":"friction","fullname":"plotOptions.networkgraph.layoutAlgorithm.friction","isLeaf":true,"default":-0.981,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Friction applied on forces to prevent nodes rushing to fast to\nthe desired positions.</p>\n","since":"7.0.0","filename":"js/Series/Networkgraph/Networkgraph.js","line":466,"lineEnd":469,"version":"fa929aa027"},{"name":"gravitationalConstant","fullname":"plotOptions.networkgraph.layoutAlgorithm.gravitationalConstant","isLeaf":true,"default":0.0625,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Gravitational const used in the barycenter force of the\nalgorithm.</p>\n","since":"7.0.0","samples":[{"name":"Custom forces with Euler integration","value":"highcharts/series-networkgraph/forces/"}],"filename":"js/Series/Networkgraph/Networkgraph.js","line":458,"lineEnd":464,"version":"fa929aa027"},{"name":"initialPositionRadius","fullname":"plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius","isLeaf":true,"default":"1","typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>When <code>initialPositions</code> are set to &#39;circle&#39;,\n<code>initialPositionRadius</code> is a distance from the center of circle,\nin which nodes are created.</p>\n","since":"7.1.0","filename":"js/Series/Networkgraph/Networkgraph.js","line":355,"lineEnd":363,"version":"fa929aa027"},{"name":"initialPositions","fullname":"plotOptions.networkgraph.layoutAlgorithm.initialPositions","isLeaf":true,"default":"circle","typeMap":{"\"circle\"":1,"\"random\"":1,"function":1},"typeList":{"names":["\"circle\"","\"random\"","function"]},"description":"<p>Initial layout algorithm for positioning nodes. Can be one of\nbuilt-in options (&quot;circle&quot;, &quot;random&quot;) or a function where\npositions should be set on each node (<code>this.nodes</code>) as\n<code>node.plotX</code> and <code>node.plotY</code></p>\n","since":"7.0.0","samples":[{"name":"Initial positions with callback","value":"highcharts/series-networkgraph/initial-positions/"}],"filename":"js/Series/Networkgraph/Networkgraph.js","line":290,"lineEnd":308,"version":"fa929aa027"},{"name":"integration","fullname":"plotOptions.networkgraph.layoutAlgorithm.integration","isLeaf":true,"default":"euler","typeMap":{"string":1},"typeList":{"names":["string"]},"description":"<p>Integration type. Available options are <code>&#39;euler&#39;</code> and <code>&#39;verlet&#39;</code>.\nIntegration determines how forces are applied on particles. In\nEuler integration, force is applied direct as\n<code>newPosition += velocity;</code>.\nIn Verlet integration, new position is based on a previous\nposittion without velocity:\n<code>newPosition += previousPosition - newPosition</code>.</p>\n<p>Note that different integrations give different results as forces\nare different.</p>\n<p>In Highcharts v7.0.x only <code>&#39;euler&#39;</code> integration was supported.</p>\n","since":"7.1.0","samples":[{"name":"Comparison of Verlet and Euler integrations","value":"highcharts/series-networkgraph/integration-comparison/"}],"filename":"js/Series/Networkgraph/Networkgraph.js","line":429,"lineEnd":449,"version":"fa929aa027"},{"name":"linkLength","fullname":"plotOptions.networkgraph.layoutAlgorithm.linkLength","isLeaf":true,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Ideal length (px) of the link between two nodes. When not\ndefined, length is calculated as:\n<code>Math.pow(availableWidth * availableHeight / nodesLength, 0.4);</code></p>\n<p>Note: Because of the algorithm specification, length of each link\nmight be not exactly as specified.</p>\n","since":"7.0.0","samples":[{"name":"Numerical values","value":"highcharts/series-networkgraph/styled-links/"}],"filename":"js/Series/Networkgraph/Networkgraph.js","line":329,"lineEnd":342,"version":"fa929aa027"},{"name":"maxIterations","fullname":"plotOptions.networkgraph.layoutAlgorithm.maxIterations","isLeaf":true,"default":1000,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Max number of iterations before algorithm will stop. In general,\nalgorithm should find positions sooner, but when rendering huge\nnumber of nodes, it is recommended to increase this value as\nfinding perfect graph positions can require more time.</p>\n","since":"7.0.0","filename":"js/Series/Networkgraph/Networkgraph.js","line":451,"lineEnd":456,"version":"fa929aa027"},{"name":"maxSpeed","fullname":"plotOptions.networkgraph.layoutAlgorithm.maxSpeed","isLeaf":true,"default":10,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Verlet integration only.\nMax speed that node can get in one iteration. In terms of\nsimulation, it&#39;s a maximum translation (in pixels) that node can\nmove (in both, x and y, dimensions). While <code>friction</code> is applied\non all nodes, max speed is applied only for nodes that move very\nfast, for example small or disconnected ones.</p>\n","since":"7.1.0","see":["<p><a href=\"#series.networkgraph.layoutAlgorithm.integration\">layoutAlgorithm.integration</a></p>\n","<p><a href=\"#series.networkgraph.layoutAlgorithm.friction\">layoutAlgorithm.friction</a></p>\n"],"filename":"js/Series/Networkgraph/Networkgraph.js","line":387,"lineEnd":399,"version":"fa929aa027"},{"name":"repulsiveForce","fullname":"plotOptions.networkgraph.layoutAlgorithm.repulsiveForce","isLeaf":true,"default":"function (d, k) { return k * k / d; }","typeMap":{"function":1},"typeList":{"names":["function"]},"description":"<p>Repulsive force applied on a node. Passed are two arguments:</p>\n<ul>\n<li><code>d</code> - which is current distance between two nodes</li>\n<li><code>k</code> - which is desired distance between two nodes</li>\n</ul>\n<p>In <code>verlet</code> integration, defaults to:\n<code>function (d, k) { return (k - d) / d * (k &gt; d ? 1 : 0) }</code></p>\n","since":"7.0.0","samples":[{"name":"Custom forces with Euler integration","value":"highcharts/series-networkgraph/forces/"},{"name":"Custom forces with Verlet integration","value":"highcharts/series-networkgraph/cuboids/"}],"see":["<p><a href=\"#series.networkgraph.layoutAlgorithm.integration\">layoutAlgorithm.integration</a></p>\n"],"filename":"js/Series/Networkgraph/Networkgraph.js","line":290,"lineEnd":308,"version":"fa929aa027"},{"name":"theta","fullname":"plotOptions.networkgraph.layoutAlgorithm.theta","isLeaf":true,"default":0.5,"typeMap":{"number":1},"typeList":{"names":["number"]},"description":"<p>Barnes-Hut approximation only.\nDeteremines when distance between cell and node is small enough\nto caculate forces. Value of <code>theta</code> is compared directly with\nquotient <code>s / d</code>, where <code>s</code> is the size of the cell, and <code>d</code> is\ndistance between center of cell&#39;s mass and currently compared\nnode.</p>\n","since":"7.1.0","see":["<p><a href=\"#series.networkgraph.layoutAlgorithm.approximation\">layoutAlgorithm.approximation</a></p>\n"],"filename":"js/Series/Networkgraph/Networkgraph.js","line":374,"lineEnd":385,"version":"fa929aa027"},{"name":"type","fullname":"plotOptions.networkgraph.layoutAlgorithm.type","isLeaf":true,"default":"reingold-fruchterman","typeMap":{"string":1},"typeList":{"names":["string"]},"description":"<p>Type of the algorithm used when positioning nodes.</p>\n","since":"7.0.0","filename":"js/Series/Networkgraph/Networkgraph.js","line":422,"lineEnd":427,"version":"fa929aa027"}]}